//*****************************************************************************
// (part 3)
// purpose: Recursive descent parsing of arithmetic expressions
//          Builds the parse tree while parsing the input
// version: Fall 2023
//  author: Joe Crumpton / Ed Swan
//*****************************************************************************

#include "parser.h"
#include "parse_tree_nodes.h"
#include <stdlib.h>
#include <iostream>

using namespace std;

// Forward declarations of first_of functions
bool first_of_expr();
bool first_of_term();
bool first_of_factor();

int nextToken = 0;            // hold nextToken returned by lex
bool printParse = false;      // shall we print the parse tree?

// Which tree level are we currently in?  Setting this to -1
// means the top-level expression is at level 0.
static int level = -1;

// Handle syntax errors
void error() {
  cout << endl << "===========================" << endl;
  cout << "ERROR near: " << yytext;
  cout << endl << "===========================" << endl;
  if (yyin)
    fclose(yyin);
  exit(EXIT_FAILURE);
}
//*****************************************************************************
// Print each level with appropriate indentation
void indent() {
  for (int i = 0; i<level; i++)
    cout << ("  ");
}
//*****************************************************************************
// Announce what the lexical analyzer has found
void output() {
  indent();
  cout << "---> FOUND " << yytext << endl;
}
//*****************************************************************************
int lex() {
  nextToken = yylex();

  if (nextToken == TOK_EOF) {
      // save a "lexeme" into yytext
      yytext[0] = 'E';
      yytext[1] = 'O';
      yytext[2] = 'F';
      yytext[3] = 0;
  }
  if(printParse) {
    // Tell us about the token and lexeme
    indent();
    cout << "Next token is: ";
    switch(nextToken) {
    case TOK_INT_LIT:      cout << "TOK_INT_LIT";     break;
    case TOK_IDENT:        cout << "TOK_IDENT";       break;
    case TOK_ADD_OP:       cout << "TOK_ADD_OP";      break;
    case TOK_SUB_OP:       cout << "TOK_SUB_OP";      break;
    case TOK_MULT_OP:      cout << "TOK_MULT_OP";     break;
    case TOK_DIV_OP:       cout << "TOK_DIV_OP";      break;
    case TOK_LEFT_PAREN:   cout << "TOK_LEFT_PAREN";  break;
    case TOK_RIGHT_PAREN:  cout << "TOK_RIGHT_PAREN"; break;
    case TOK_EOF:          cout << "TOK_EOF";         break;
    case TOK_UNKNOWN:      cout << "TOK_UNKNOWN";     break;
    default: error();
    }
    cout << ", Next lexeme is: " << yytext << endl;
  }
  return nextToken;
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <expr> -> <term> {{ (( + || - )) <term> }}
ExprNode* expr() {
  // Check that the <expr> starts with a valid token 
  if(!first_of_expr())
    error();

  if(printParse) {
    indent();
    cout << "Enter <expr>" << endl;
  }
  level = level + 1;
  ExprNode* newExprNode = new ExprNode(level);

  /* Parse the first term */
  newExprNode->firstTerm = term();

  // As long as the next token is + or -, get the next token and parse the next term
  while(nextToken == TOK_ADD_OP || nextToken == TOK_SUB_OP) {
    if(printParse) output();
    newExprNode->restTermOps.push_back(nextToken);
    lex();
    newExprNode->restTerms.push_back(term());
  }

  level = level - 1;
  if(printParse) {
    indent();
    cout << "Exit <expr>" << endl;
  }
  return newExprNode;
}
bool first_of_expr(){
  return nextToken == TOK_LEFT_PAREN || nextToken == TOK_IDENT || nextToken == TOK_INT_LIT;
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <term> -> <factor> {{ (( * || / )) <factor> })
TermNode* term() {
  /* Check that the <term> starts with a valid token */
  if(!first_of_term())
    error();

  if(printParse) {
    indent();
    cout << "Enter <term>" << endl;
  }
  level = level + 1;
  TermNode* newTermNode = new TermNode(level);

  /* Parse the first factor */
  newTermNode->firstFactor = factor();

  /* As long as the next token is * or /, get the
     next token and parse the next factor */
  while(nextToken == TOK_MULT_OP || nextToken == TOK_DIV_OP) {
    if(printParse) output();
    newTermNode->restFactorOps.push_back(nextToken);
    lex();
    newTermNode->restFactors.push_back(factor());
  }

  level = level - 1;
  if(printParse) {
    indent();
    cout << "Exit <term>" << endl;
  }
  return newTermNode;
}
bool first_of_term(){
  return nextToken == TOK_LEFT_PAREN || nextToken == TOK_IDENT || nextToken == TOK_INT_LIT;
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <factor> -> id || int_constant || ( <expr> )
FactorNode* factor() {
  // Check that the <factor> starts with a valid token
  if(!first_of_factor())
    error();

  if(printParse) {
  indent();
  cout << "Enter <factor>" << endl;
  }
  level = level + 1;
  FactorNode* newFactorNode = nullptr;

  // Determine which RHS token we have
  switch(nextToken) {

    case TOK_IDENT:
      if(printParse) output();
      newFactorNode = new IdNode(level, string(yytext));
      nextToken = lex(); // Read past what we have found
      break;

    case TOK_INT_LIT:
      if(printParse) output();
      newFactorNode = new IntLitNode(level, atoi(yytext));
      nextToken = lex();
      break;

    case TOK_LEFT_PAREN:
      // We expect ( <expr> ) parse it
      if(printParse) output();
      nextToken = lex();
      if (!first_of_expr()) // Check for 'IDENT' | 'INT_LIT' | (
        error();

      newFactorNode = new NestedExprNode(level, expr());

      if (nextToken == TOK_RIGHT_PAREN) {
        if(printParse) output();
        nextToken = lex();
      }
      else
        throw "<expr> does not end with )";
      break;

    default:
      // If we made it to here, syntax error
      error();
	}
  level = level - 1;
  if(printParse) {
    indent();
    cout << "Exit <factor>" << endl;
  }
  return newFactorNode;
}
bool first_of_factor(){
  return nextToken == TOK_LEFT_PAREN || nextToken == TOK_IDENT || nextToken == TOK_INT_LIT;
}


