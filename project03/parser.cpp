//*****************************************************************************
// (part 3)
// purpose: Recursive descent parsing of arithmetic expressions
//          Builds the parse tree while parsing the input
// version: Fall 2023
//  author: Joe Crumpton / Ed Swan
//*****************************************************************************

#include "parser.h"
#include "parse_tree_nodes.h"
#include <stdlib.h>
#include <iostream>

using namespace std;

// Forward declarations of first_of functions
bool first_of_expr();
bool first_of_term();
bool first_of_factor();
bool first_of_simple_exp();
bool first_of_block();
bool first_of_program();

int nextToken = 0;            // hold nextToken returned by lex
bool printParse = false;      // shall we print the parse tree?

// Which tree level are we currently in?  Setting this to -1
// means the top-level expression is at level 0.
static int level = -1;

set<string> symbolTable; // Symbol Table

//*****************************************************************************
// Indent to reveal tree structure
string psp(void)
{ // Stands for p-space, but I want the name short
  string str("");
  for (int i = 0; i < level; i++)
    str += "|  ";
  return str;
}
//*****************************************************************************
// Report what we found
void output(string what)
{
  cout << psp() << "found |" << yytext << "| " << what << endl;
}

// Handle syntax errors
void error() {
  cout << endl << "===========================" << endl;
  cout << "ERROR near: " << yytext;
  cout << endl << "===========================" << endl;
  if (yyin)
    fclose(yyin);
  exit(EXIT_FAILURE);
}
//*****************************************************************************
// Print each level with appropriate indentation
void indent() {
  for (int i = 0; i<level; i++)
    cout << ("  ");
}
//*****************************************************************************
// Announce what the lexical analyzer has found
void output() {
  indent();
  cout << "---> FOUND " << yytext << endl;
}
//*****************************************************************************
int lex() {
  nextToken = yylex();

  if (nextToken == TOK_EOF) {
      // save a "lexeme" into yytext
      yytext[0] = 'E';
      yytext[1] = 'O';
      yytext[2] = 'F';
      yytext[3] = 0;
  }
  if(printParse) {
    // Tell us about the token and lexeme
    indent();
    cout << "Next token is: ";
    switch(nextToken) {
    case TOK_INTLIT:      cout << "TOK_INTLIT";     break;
    case TOK_IDENT:        cout << "TOK_IDENT";       break;
    case TOK_PLUS:       cout << "TOK_PLUS";      break;
    case TOK_MINUS:       cout << "TOK_SUB_OP";      break;
    case TOK_MULTIPLY:      cout << "TOK_MULT_OP";     break;
    case TOK_DIVIDE:       cout << "TOK_DIV_OP";      break;
    case TOK_OPENPAREN:   cout << "TOK_LEFT_PAREN";  break;
    case TOK_CLOSEPAREN:  cout << "TOK_RIGHT_PAREN"; break;
    case TOK_EOF:          cout << "TOK_EOF";         break;
    case TOK_UNKNOWN:      cout << "TOK_UNKNOWN";     break;
    default: error();
    }
    cout << ", Next lexeme is: " << yytext << endl;
  }
  return nextToken;
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <factor> -> id || int_constant || ( <expr> )
FactorNode* factor() {
  // Check that the <factor> starts with a valid token
  if(!first_of_factor())
    error();

  if(printParse) {
  indent();
  cout << "Enter <factor>" << endl;
  }
  level = level + 1;
  FactorNode* newFactorNode = nullptr;

  // Determine which RHS token we have
  switch(nextToken) {

    case TOK_IDENT:
      if(printParse) output();
      newFactorNode = new IdNode(level, string(yytext));
      nextToken = lex(); // Read past what we have found
      break;

    case TOK_INTLIT:
      if(printParse) output();
      newFactorNode = new IntLitNode(level, atoi(yytext));
      nextToken = lex();
      break;

    case TOK_OPENPAREN:
      // We expect ( <expr> ) parse it
      if(printParse) output();
      nextToken = lex();
      if (!first_of_expr()) // Check for 'IDENT' | 'INT_LIT' | (
        error();

      newFactorNode = new NestedExprNode(level, expr());

      if (nextToken == TOK_CLOSEPAREN) {
        if(printParse) output();
        nextToken = lex();
      }
      else
        throw "<expr> does not end with )";
      break;

	}

  if (nextToken == TOK_NOT) {
    if(printParse) output();
    newFactorNode = new NotNode(level, factor());
    nextToken = lex();
  }

  else if (nextToken == TOK_MINUS) {
      if(printParse) output();
      newFactorNode = new MinusNode(level, factor());
      nextToken = lex();
  }

/*
  else {
    // If we made it to here, syntax error
    error();
  }
*/

  level = level - 1;
  if(printParse) {
    indent();
    cout << "Exit <factor>" << endl;
  }
  return newFactorNode;
}
bool first_of_factor(){
  return nextToken == TOK_OPENPAREN || nextToken == TOK_IDENT || nextToken == TOK_INTLIT;
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <term> -> <factor> {{ (( * || /  || AND )) <factor> })
TermNode* term() {
  /* Check that the <term> starts with a valid token */
  if(!first_of_term())
    error();

  if(printParse) {
    indent();
    cout << "Enter <term>" << endl;
  }
  level = level + 1;
  TermNode* newTermNode = new TermNode(level);

  /* Parse the first factor */
  newTermNode->firstFactor = factor();

  /* As long as the next token is * or /, get the
     next token and parse the next factor */
  while (nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE || nextToken == TOK_AND) {
    if(printParse) output();
    newTermNode->restFactorOps.push_back(nextToken);
    cout << "Term" << nextToken << endl;
    lex();
    newTermNode->restFactors.push_back(factor());
  }

  level = level - 1;
  if(printParse) {
    indent();
    cout << "Exit <term>" << endl;
  }
  return newTermNode;
}
bool first_of_term(){
  return nextToken == TOK_OPENPAREN || nextToken == TOK_IDENT || nextToken == TOK_INTLIT;
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
ExprNode* expr() {
  // Check that the <expr> starts with a valid token 
  if(!first_of_expr())
    error();

  if(printParse) {
    indent();
    cout << "Enter <expression>" << endl;
  }
  level = level + 1;
  ExprNode* newExprNode = new ExprNode(level);

  /* Parse the first term */
  newExprNode->firstSimpleExp = simple_exp();

  // As long as the next token is + or -, get the next token and parse the next term
  while (nextToken == TOK_EQUALTO || nextToken == TOK_LESSTHAN || nextToken == TOK_GREATERTHAN || nextToken == TOK_NOTEQUALTO) {
    if(printParse) output();
    newExprNode->restSimpleExpOps.push_back(nextToken);
    lex();
    newExprNode->restSimpleExps.push_back(simple_exp());
  }

  level = level - 1;
  if(printParse) {
    indent();
    cout << "Exit <expression>" << endl;
  }
  return newExprNode;
}
bool first_of_expr(){
  return nextToken == TOK_OPENPAREN || nextToken == TOK_IDENT || nextToken == TOK_INTLIT;
}
SimpleExpNode* simple_exp() {
  if(!first_of_simple_exp())
    error();

  if(printParse) {
    indent();
    cout << "Enter <simple_exp>" << endl;
  }
  level = level + 1;
  SimpleExpNode* newSimpleExpNode = new SimpleExpNode(level);

  /* Parse the first term */
  newSimpleExpNode->firstTerm = term();

  // cout << "SIMPLE EXP" << nextToken << endl;

  newSimpleExpNode->restTermOps.push_back(nextToken);
  lex();
  newSimpleExpNode->restTerms.push_back(term());
  

  /* As long as the next token is * or /, get the
     next token and parse the next factor */
  if (nextToken == TOK_PLUS || nextToken == TOK_MINUS || nextToken == TOK_OR) {
    if(printParse) output();
    cout << "SIMPLE EXP" << nextToken << endl;
    newSimpleExpNode->restTermOps.push_back(nextToken);
    lex();
    newSimpleExpNode->restTerms.push_back(term());
  }

  level = level - 1;
  if(printParse) {
    indent();
    cout << "Exit <simple_exp>" << endl;
  }
  return newSimpleExpNode;
}
bool first_of_simple_exp() {
  return nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT || nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN || nextToken == TOK_NOT || nextToken == TOK_MINUS;
}

// TODO: more stuff here

BlockNode* block() {
  if(!first_of_block())
    error();

  if(printParse) {
    indent();
    cout << "Enter <block>" << endl;
  }
  level = level + 1;

  BlockNode* newBlockNode = new BlockNode(level);

  if(nextToken == TOK_VAR) {
    lex();
    if(nextToken != TOK_IDENT) throw "TODO";
    
    string idName;
    idName = yytext;

    lex();
    if(nextToken != TOK_COLON) throw "TODO";

    string idType;
    lex();
    if (nextToken == TOK_REAL || nextToken == TOK_INTEGER)
      if(printParse) output("TYPE");
    else
      throw "10: error in type";
    idType = yytext;

    lex();
    if(nextToken != TOK_SEMICOLON) throw "TODO";

    if(printParse)
      cout << psp() << "-- idName: |" << idName << "| idType: |" << idType << "| --" << endl;

    if(symbolTable.find(idName) != symbolTable.end())
      throw "101: identifier declared twice";
    
    symbolTable.insert(idName);
  }

  if(nextToken == TOK_BEGIN) {
    // TODO: equivalent of lex(false)
    lex();
  }

  // statement();

  level = level - 1;
  if(printParse) {
    indent();
    cout << "Exit <block>" << endl;
  }
}
bool first_of_block() {
  return nextToken == TOK_VAR || nextToken == TOK_BEGIN;
}

ProgramNode* program() {
  if(!first_of_program())
    error();
  
  if(printParse) {
    indent();
    cout << "Enter <program>" << endl;
  }
  level = level + 1;
  ProgramNode* newProgramNode = new ProgramNode(level);

  lex();
  if(nextToken != TOK_IDENT) throw "2: identifier expected";
  lex();
  if(nextToken != TOK_SEMICOLON) throw "14: ';' expected";

  newProgramNode->block = block();

  level = level - 1;
  if(printParse) {
    indent();
    cout << "Exit <program>" << endl;
  }
  return newProgramNode;
}
bool first_of_program() {
  return nextToken == TOK_PROGRAM;
}


